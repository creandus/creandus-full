#!/bin/bash
# Copyright 2006 Mike Kelly
# Distributed under the terms of the GNU General Public License v2
#
# addgroup.bash - intelligently adds a new group for the system package
# manager.
#
# $Id$

SCRIPTDIR=${SCRIPTDIR:-@SCRIPTDIR@}

# Load the basic configuration.
. "${SCRIPTDIR}/common/config.bash"
. "${SCRIPTDIR}/common/functions.bash"

# We make use of egetent. 
. "${SCRIPTDIR}/common/getent.bash"
# Reads the proper data file for the desired group
. "${SCRIPTDIR}/common/read_groupdata.bash"

main() {
	# Read the command line arguments.

	# The only options recognized now are the group to be added, the 
	# package which is asking for the adding, and the userspace type (e.g. 
	# GNU, fbsd, etc)
	local newgroup=${1} pkgname=${2} userspace=${3} root=${4:-/}

	[[ -z "${newgroup}" || -z "${pkgname}" || -z "${userspace}" \
	|| -z "${root}" ]] \
	&& die "Script expects 4 arguments: groupname pkgname userspace root"

	# Set our default action. Will be either "add" or "mod" by the end.
	action="add"

	###
	eval `read_groupdata "${newgroup}"`

	# TODO: allow for more sophisticated range specifications
	local gidmin=${groupid%-*} gidmax=${groupid#*-}

	groupid=${gidmin}
	for i in $( seq ${groupid} ${gidmax} ) ; do
		[[ -z $(egetent group ${i}) ]] && groupid=${i} && break
	done

	# Now, we verify this information against our database, and if there
	# isn't a match (either some value has changed, or there is no entry
	# at all), we take appropriate action

	# See if the group already exists
	if [[ ${newgroup} == $(egetent group "${newgroup}" | cut -d: -f1) ]]
	then
		# TODO: If there needs to be some change made, note it
		# properly, for the operator to take care of later with
		# the eselect tool
		local getentinfo=$(egetent group "${newgroup}")
		
		local currgid=$(echo ${getentinfo} | cut -d: -f3)
		if [[ ${currgid} -ne ${groupid} ]] ; then
			echo "The group ${newgroup} needs some values changed."
			echo "We're doing so now."
			action="mod"
		else
			# Now, since we've made the proper arrangements for any 
			# possible changes, we now add the current package name 
			# to the database and call it quits
			echo "We already have a group named ${newgroup}." \
				"Nothing to do." 1>&2

			"${SCRIPTDIR}/db.bash" add group "${pkgname}" \
				"${newgroup}" "${userspace}"

			exit 0
		fi
	fi

	if [[ -f "${DBDIR}/group/${newgroup}" ]] ; then
		echo "Group ${newgroup} was previously added by this script," >&2
		echo "but it no longer exists on the system. We'll re-add" >&2
		echo "them now, but you should have used the users-config" >&2
		echo "tool to cleanly remove it." >&2
		echo >&2
	fi

	# Finally, we take take the necessary action, either via groupmod 
	# or groupadd [or it's comparable friends]
	for x in ${GROUP_BACKENDS}; do
		if [[ -e "${SCRIPTDIR}/auth/${x}-${userspace}-group${action}.bash" ]] 
		then
			echo "Running ${x}-${userspace}-group${action}..."
			. "${SCRIPTDIR}/auth/${x}-${userspace}-group${action}.bash"
			"${x}-${userspace}-group${action}" "${groupid}"
		else
			echo -n "Auth backend ${x} with " >&2
			echo -n "userspace ${userspace} " >&2
			echo "not supported by this script." >&2
		fi
	done

	# Properly update the dynamic groups database
	"${SCRIPTDIR}/db.bash" add group "${pkgname}" "${newgroup}" "${userspace}"
}

if [[ "${1}" == "--test" ]] ; then
	echo "Syntax OK."
	exit 0
fi

main $@
# vim: ts=4 :
